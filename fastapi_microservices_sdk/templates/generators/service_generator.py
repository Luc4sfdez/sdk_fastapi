"""
Service Generator for FastAPI microservices.
"""

from pathlib import Path
from typing import Dict, Any, List
from .base import CodeGenerator


class ServiceGenerator(CodeGenerator):
    """Generate service layer components."""
    
    def __init__(self, config):
        super().__init__(
            name="service_generator",
            description="Generate service layer components"
        )
        self.config = config
    
    def generate(self, variables: Dict[str, Any], output_path: Path) -> List[Path]:
        """Generate service files."""
        
        generated_files = []
        
        # Generate main service class
        service_file = self._generate_service_class(variables, output_path)
        generated_files.append(service_file)
        
        # Generate repository if needed
        if variables.get("enable_repository", True):
            repository_file = self._generate_repository_class(variables, output_path)
            generated_files.append(repository_file)
        
        # Generate exceptions if error handling is enabled
        if variables.get("enable_error_handling", True):
            exceptions_file = self._generate_exceptions(variables, output_path)
            generated_files.append(exceptions_file)
        
        return generated_files
    
    def _generate_service_class(self, variables: Dict[str, Any], output_path: Path) -> Path:
        """Generate service class file."""
        
        service_name = variables.get("service_name", "item_service")
        template_type = variables.get("template_type", "base")
        enable_async = variables.get("enable_async", True)
        enable_logging = variables.get("enable_logging", True)
        enable_error_handling = variables.get("enable_error_handling", True)
        
        # Extract model name from service name
        model_name = service_name.replace("_service", "").replace("-service", "")
        
        service_content = f'''"""
Service layer for {model_name}.
Generated by FastAPI Microservices SDK.
"""

from typing import List, Optional, Dict, Any
'''
        
        if enable_async:
            service_content += '''from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, update, delete
'''
        else:
            service_content += '''from sqlalchemy.orm import Session
'''
        
        if enable_logging:
            service_content += '''import logging
'''
        
        if enable_error_handling:
            service_content += f'''from .exceptions import {model_name.title()}NotFoundError, {model_name.title()}ValidationError
'''
        
        service_content += f'''
from ..models.{model_name} import {model_name.title()}
from ..schemas.{model_name} import {model_name.title()}Create, {model_name.title()}Update
from ..repositories.{model_name}_repository import {model_name.title()}Repository

'''
        
        if enable_logging:
            service_content += f'''
logger = logging.getLogger(__name__)

'''
        
        # Generate service class
        async_prefix = "async " if enable_async else ""
        await_prefix = "await " if enable_async else ""
        session_type = "AsyncSession" if enable_async else "Session"
        
        service_content += f'''
class {model_name.title()}Service:
    """Service class for {model_name} business logic."""
    
    def __init__(self, db: {session_type}):
        self.db = db
        self.repository = {model_name.title()}Repository(db)
'''
        
        if enable_logging:
            service_content += f'''        self.logger = logger
'''
        
        service_content += f'''
    {async_prefix}def get_all(
        self, 
        skip: int = 0, 
        limit: int = 100,
        filters: Optional[Dict[str, Any]] = None
    ) -> List[{model_name.title()}]:
        """Get all {model_name}s with optional filtering."""
'''
        
        if enable_logging:
            service_content += f'''        self.logger.info(f"Getting all {model_name}s with skip={{skip}}, limit={{limit}}")
'''
        
        service_content += f'''        
        try:
            return {await_prefix}self.repository.get_all(skip=skip, limit=limit, filters=filters)
        except Exception as e:
'''
        
        if enable_logging:
            service_content += f'''            self.logger.error(f"Error getting all {model_name}s: {{e}}")
'''
        
        if enable_error_handling:
            service_content += f'''            raise {model_name.title()}ValidationError(f"Failed to retrieve {model_name}s: {{str(e)}}")
'''
        else:
            service_content += '''            raise
'''
        
        service_content += f'''
    {async_prefix}def get_by_id(self, item_id: int) -> Optional[{model_name.title()}]:
        """Get {model_name} by ID."""
'''
        
        if enable_logging:
            service_content += f'''        self.logger.info(f"Getting {model_name} with ID: {{item_id}}")
'''
        
        service_content += f'''        
        try:
            return {await_prefix}self.repository.get_by_id(item_id)
        except Exception as e:
'''
        
        if enable_logging:
            service_content += f'''            self.logger.error(f"Error getting {model_name} {{item_id}}: {{e}}")
'''
        
        if enable_error_handling:
            service_content += f'''            raise {model_name.title()}ValidationError(f"Failed to retrieve {model_name}: {{str(e)}}")
'''
        else:
            service_content += '''            raise
'''
        
        service_content += f'''
    {async_prefix}def create(self, item_data: {model_name.title()}Create) -> {model_name.title()}:
        """Create new {model_name}."""
'''
        
        if enable_logging:
            service_content += f'''        self.logger.info(f"Creating new {model_name}")
'''
        
        service_content += f'''        
        try:
            # Validate business rules
            {await_prefix}self._validate_create(item_data)
            
            # Create the item
            db_item = {model_name.title()}(**item_data.model_dump())
            return {await_prefix}self.repository.create(db_item)
        except Exception as e:
'''
        
        if enable_logging:
            service_content += f'''            self.logger.error(f"Error creating {model_name}: {{e}}")
'''
        
        if enable_error_handling:
            service_content += f'''            raise {model_name.title()}ValidationError(f"Failed to create {model_name}: {{str(e)}}")
'''
        else:
            service_content += '''            raise
'''
        
        service_content += f'''
    {async_prefix}def update(self, item_id: int, item_data: {model_name.title()}Update) -> Optional[{model_name.title()}]:
        """Update {model_name}."""
'''
        
        if enable_logging:
            service_content += f'''        self.logger.info(f"Updating {model_name} {{item_id}}")
'''
        
        service_content += f'''        
        try:
            # Check if item exists
            existing_item = {await_prefix}self.repository.get_by_id(item_id)
            if not existing_item:
'''
        
        if enable_error_handling:
            service_content += f'''                raise {model_name.title()}NotFoundError(f"{model_name.title()} with ID {{item_id}} not found")
'''
        else:
            service_content += '''                return None
'''
        
        service_content += f'''            
            # Validate business rules
            {await_prefix}self._validate_update(item_id, item_data)
            
            # Update the item
            update_data = item_data.model_dump(exclude_unset=True)
            return {await_prefix}self.repository.update(item_id, update_data)
        except Exception as e:
'''
        
        if enable_logging:
            service_content += f'''            self.logger.error(f"Error updating {model_name} {{item_id}}: {{e}}")
'''
        
        service_content += '''            raise
'''
        
        service_content += f'''
    {async_prefix}def delete(self, item_id: int) -> bool:
        """Delete {model_name}."""
'''
        
        if enable_logging:
            service_content += f'''        self.logger.info(f"Deleting {model_name} {{item_id}}")
'''
        
        service_content += f'''        
        try:
            # Check if item exists
            existing_item = {await_prefix}self.repository.get_by_id(item_id)
            if not existing_item:
'''
        
        if enable_error_handling:
            service_content += f'''                raise {model_name.title()}NotFoundError(f"{model_name.title()} with ID {{item_id}} not found")
'''
        else:
            service_content += '''                return False
'''
        
        service_content += f'''            
            # Validate business rules for deletion
            {await_prefix}self._validate_delete(item_id)
            
            # Delete the item
            return {await_prefix}self.repository.delete(item_id)
        except Exception as e:
'''
        
        if enable_logging:
            service_content += f'''            self.logger.error(f"Error deleting {model_name} {{item_id}}: {{e}}")
'''
        
        service_content += '''            raise
'''
        
        service_content += f'''
    {async_prefix}def search(
        self, 
        query: str, 
        skip: int = 0, 
        limit: int = 100
    ) -> List[{model_name.title()}]:
        """Search {model_name}s."""
'''
        
        if enable_logging:
            service_content += f'''        self.logger.info(f"Searching {model_name}s with query: {{query}}")
'''
        
        service_content += f'''        
        try:
            return {await_prefix}self.repository.search(query, skip=skip, limit=limit)
        except Exception as e:
'''
        
        if enable_logging:
            service_content += f'''            self.logger.error(f"Error searching {model_name}s: {{e}}")
'''
        
        if enable_error_handling:
            service_content += f'''            raise {model_name.title()}ValidationError(f"Failed to search {model_name}s: {{str(e)}}")
'''
        else:
            service_content += '''            raise
'''
        
        # Add validation methods
        service_content += f'''
    {async_prefix}def _validate_create(self, item_data: {model_name.title()}Create) -> None:
        """Validate business rules for creation."""
        # Add your business validation logic here
        pass
    
    {async_prefix}def _validate_update(self, item_id: int, item_data: {model_name.title()}Update) -> None:
        """Validate business rules for update."""
        # Add your business validation logic here
        pass
    
    {async_prefix}def _validate_delete(self, item_id: int) -> None:
        """Validate business rules for deletion."""
        # Add your business validation logic here
        pass
    
    {async_prefix}def count(self, filters: Optional[Dict[str, Any]] = None) -> int:
        """Count {model_name}s with optional filtering."""
        try:
            return {await_prefix}self.repository.count(filters=filters)
        except Exception as e:
'''
        
        if enable_logging:
            service_content += f'''            self.logger.error(f"Error counting {model_name}s: {{e}}")
'''
        
        service_content += '''            raise
'''
        
        service_file = output_path / f"{service_name}.py"
        service_file.write_text(service_content)
        
        return service_file
    
    def _generate_repository_class(self, variables: Dict[str, Any], output_path: Path) -> Path:
        """Generate repository class file."""
        
        service_name = variables.get("service_name", "item_service")
        enable_async = variables.get("enable_async", True)
        
        # Extract model name from service name
        model_name = service_name.replace("_service", "").replace("-service", "")
        
        repository_content = f'''"""
Repository for {model_name} data access.
Generated by FastAPI Microservices SDK.
"""

from typing import List, Optional, Dict, Any
'''
        
        if enable_async:
            repository_content += '''from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, update, delete, func, or_
from sqlalchemy.orm import selectinload
'''
        else:
            repository_content += '''from sqlalchemy.orm import Session
from sqlalchemy import and_, or_, func
'''
        
        repository_content += f'''
from ..models.{model_name} import {model_name.title()}

'''
        
        # Generate repository class
        async_prefix = "async " if enable_async else ""
        await_prefix = "await " if enable_async else ""
        session_type = "AsyncSession" if enable_async else "Session"
        
        repository_content += f'''
class {model_name.title()}Repository:
    """Repository class for {model_name} data access."""
    
    def __init__(self, db: {session_type}):
        self.db = db
    
    {async_prefix}def get_all(
        self, 
        skip: int = 0, 
        limit: int = 100,
        filters: Optional[Dict[str, Any]] = None
    ) -> List[{model_name.title()}]:
        """Get all {model_name}s with optional filtering."""
'''
        
        if enable_async:
            repository_content += f'''        query = select({model_name.title()})
        
        # Apply filters if provided
        if filters:
            for key, value in filters.items():
                if hasattr({model_name.title()}, key):
                    query = query.where(getattr({model_name.title()}, key) == value)
        
        query = query.offset(skip).limit(limit)
        result = await self.db.execute(query)
        return result.scalars().all()
'''
        else:
            repository_content += f'''        query = self.db.query({model_name.title()})
        
        # Apply filters if provided
        if filters:
            for key, value in filters.items():
                if hasattr({model_name.title()}, key):
                    query = query.filter(getattr({model_name.title()}, key) == value)
        
        return query.offset(skip).limit(limit).all()
'''
        
        repository_content += f'''
    {async_prefix}def get_by_id(self, item_id: int) -> Optional[{model_name.title()}]:
        """Get {model_name} by ID."""
'''
        
        if enable_async:
            repository_content += f'''        query = select({model_name.title()}).where({model_name.title()}.id == item_id)
        result = await self.db.execute(query)
        return result.scalar_one_or_none()
'''
        else:
            repository_content += f'''        return self.db.query({model_name.title()}).filter({model_name.title()}.id == item_id).first()
'''
        
        repository_content += f'''
    {async_prefix}def create(self, item: {model_name.title()}) -> {model_name.title()}:
        """Create new {model_name}."""
        self.db.add(item)
        {await_prefix}self.db.commit()
        {await_prefix}self.db.refresh(item)
        return item
    
    {async_prefix}def update(self, item_id: int, update_data: Dict[str, Any]) -> Optional[{model_name.title()}]:
        """Update {model_name}."""
'''
        
        if enable_async:
            repository_content += f'''        query = update({model_name.title()}).where({model_name.title()}.id == item_id).values(**update_data)
        await self.db.execute(query)
        await self.db.commit()
        
        # Return updated item
        return await self.get_by_id(item_id)
'''
        else:
            repository_content += f'''        item = self.db.query({model_name.title()}).filter({model_name.title()}.id == item_id).first()
        if item:
            for key, value in update_data.items():
                if hasattr(item, key):
                    setattr(item, key, value)
            self.db.commit()
            self.db.refresh(item)
        return item
'''
        
        repository_content += f'''
    {async_prefix}def delete(self, item_id: int) -> bool:
        """Delete {model_name}."""
'''
        
        if enable_async:
            repository_content += f'''        query = delete({model_name.title()}).where({model_name.title()}.id == item_id)
        result = await self.db.execute(query)
        await self.db.commit()
        return result.rowcount > 0
'''
        else:
            repository_content += f'''        item = self.db.query({model_name.title()}).filter({model_name.title()}.id == item_id).first()
        if item:
            self.db.delete(item)
            self.db.commit()
            return True
        return False
'''
        
        repository_content += f'''
    {async_prefix}def search(self, query: str, skip: int = 0, limit: int = 100) -> List[{model_name.title()}]:
        """Search {model_name}s by name or description."""
'''
        
        if enable_async:
            repository_content += f'''        search_query = select({model_name.title()}).where(
            or_(
                {model_name.title()}.name.ilike(f"%{{query}}%"),
                {model_name.title()}.description.ilike(f"%{{query}}%")
            )
        ).offset(skip).limit(limit)
        
        result = await self.db.execute(search_query)
        return result.scalars().all()
'''
        else:
            repository_content += f'''        return self.db.query({model_name.title()}).filter(
            or_(
                {model_name.title()}.name.ilike(f"%{{query}}%"),
                {model_name.title()}.description.ilike(f"%{{query}}%")
            )
        ).offset(skip).limit(limit).all()
'''
        
        repository_content += f'''
    {async_prefix}def count(self, filters: Optional[Dict[str, Any]] = None) -> int:
        """Count {model_name}s with optional filtering."""
'''
        
        if enable_async:
            repository_content += f'''        query = select(func.count({model_name.title()}.id))
        
        # Apply filters if provided
        if filters:
            for key, value in filters.items():
                if hasattr({model_name.title()}, key):
                    query = query.where(getattr({model_name.title()}, key) == value)
        
        result = await self.db.execute(query)
        return result.scalar()
'''
        else:
            repository_content += f'''        query = self.db.query(func.count({model_name.title()}.id))
        
        # Apply filters if provided
        if filters:
            for key, value in filters.items():
                if hasattr({model_name.title()}, key):
                    query = query.filter(getattr({model_name.title()}, key) == value)
        
        return query.scalar()
'''
        
        repository_file = output_path / f"{model_name}_repository.py"
        repository_file.write_text(repository_content)
        
        return repository_file
    
    def _generate_exceptions(self, variables: Dict[str, Any], output_path: Path) -> Path:
        """Generate custom exceptions."""
        
        service_name = variables.get("service_name", "item_service")
        
        # Extract model name from service name
        model_name = service_name.replace("_service", "").replace("-service", "")
        
        exceptions_content = f'''"""
Custom exceptions for {model_name} service.
Generated by FastAPI Microservices SDK.
"""


class {model_name.title()}ServiceError(Exception):
    """Base exception for {model_name} service errors."""
    pass


class {model_name.title()}NotFoundError({model_name.title()}ServiceError):
    """Exception raised when {model_name} is not found."""
    pass


class {model_name.title()}ValidationError({model_name.title()}ServiceError):
    """Exception raised when {model_name} validation fails."""
    pass


class {model_name.title()}AlreadyExistsError({model_name.title()}ServiceError):
    """Exception raised when {model_name} already exists."""
    pass


class {model_name.title()}PermissionError({model_name.title()}ServiceError):
    """Exception raised when user doesn't have permission for {model_name} operation."""
    pass
'''
        
        exceptions_file = output_path / "exceptions.py"
        exceptions_file.write_text(exceptions_content)
        
        return exceptions_file