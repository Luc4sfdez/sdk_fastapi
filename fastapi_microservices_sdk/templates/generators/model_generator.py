"""
Model Generator for FastAPI microservices.
"""

from pathlib import Path
from typing import Dict, Any, List
from .base import CodeGenerator


class ModelGenerator(CodeGenerator):
    """Generate database models and schemas."""
    
    def __init__(self, config):
        super().__init__(
            name="model_generator",
            description="Generate database models and schemas"
        )
        self.config = config
    
    def generate(self, variables: Dict[str, Any], output_path: Path) -> List[Path]:
        """Generate model files."""
        
        generated_files = []
        
        database_type = variables.get("database_type", "sqlalchemy")
        
        if database_type == "sqlalchemy":
            model_file = self._generate_sqlalchemy_model(variables, output_path)
        elif database_type == "mongoengine":
            model_file = self._generate_mongoengine_model(variables, output_path)
        else:
            model_file = self._generate_generic_model(variables, output_path)
        
        generated_files.append(model_file)
        
        # Generate Pydantic schemas if validation is enabled
        if variables.get("enable_validation", True):
            schema_file = self._generate_pydantic_schemas(variables, output_path)
            generated_files.append(schema_file)
        
        return generated_files
    
    def _generate_sqlalchemy_model(self, variables: Dict[str, Any], output_path: Path) -> Path:
        """Generate SQLAlchemy model."""
        
        model_name = variables.get("model_name", "Item")
        fields = variables.get("fields", [])
        enable_timestamps = variables.get("enable_timestamps", True)
        
        model_content = f'''"""
SQLAlchemy model for {model_name}.
Generated by FastAPI Microservices SDK.
"""

from sqlalchemy import Column, Integer, String, Boolean, DateTime, Text, Float, ForeignKey
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from datetime import datetime

Base = declarative_base()


class {model_name}(Base):
    """Database model for {model_name.lower()}."""
    
    __tablename__ = "{model_name.lower()}s"
    
    id = Column(Integer, primary_key=True, index=True)
'''
        
        # Add custom fields
        for field in fields:
            field_name = field.get("name", "field")
            field_type = field.get("type", "str")
            
            if field_type in ["str", "string"]:
                model_content += f'    {field_name} = Column(String(255), index=True)\n'
            elif field_type in ["int", "integer"]:
                model_content += f'    {field_name} = Column(Integer)\n'
            elif field_type in ["float", "decimal"]:
                model_content += f'    {field_name} = Column(Float)\n'
            elif field_type in ["bool", "boolean"]:
                model_content += f'    {field_name} = Column(Boolean, default=False)\n'
            elif field_type == "text":
                model_content += f'    {field_name} = Column(Text)\n'
            else:
                model_content += f'    {field_name} = Column(String(255))\n'
        
        # Add default fields if no custom fields
        if not fields:
            model_content += '''    name = Column(String(255), index=True, nullable=False)
    description = Column(Text, nullable=True)
    is_active = Column(Boolean, default=True)
'''
        
        # Add timestamps if enabled
        if enable_timestamps:
            model_content += '''    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)
'''
        
        model_content += f'''
    def __repr__(self):
        return f"<{model_name}(id={{self.id}}, name={{getattr(self, 'name', 'N/A')}})"
    
    def to_dict(self):
        """Convert model to dictionary."""
        return {{
            column.name: getattr(self, column.name)
            for column in self.__table__.columns
        }}
'''
        
        model_file = output_path / f"{model_name.lower()}.py"
        model_file.write_text(model_content)
        
        return model_file
    
    def _generate_mongoengine_model(self, variables: Dict[str, Any], output_path: Path) -> Path:
        """Generate MongoEngine model."""
        
        model_name = variables.get("model_name", "Item")
        fields = variables.get("fields", [])
        enable_timestamps = variables.get("enable_timestamps", True)
        
        model_content = f'''"""
MongoEngine model for {model_name}.
Generated by FastAPI Microservices SDK.
"""

from mongoengine import Document, StringField, BooleanField, DateTimeField, IntField, FloatField
from datetime import datetime


class {model_name}(Document):
    """MongoDB document for {model_name.lower()}."""
    
    meta = {{
        'collection': '{model_name.lower()}s',
        'indexes': ['name']
    }}
    
'''
        
        # Add custom fields
        for field in fields:
            field_name = field.get("name", "field")
            field_type = field.get("type", "str")
            
            if field_type in ["str", "string"]:
                model_content += f'    {field_name} = StringField(max_length=255)\n'
            elif field_type in ["int", "integer"]:
                model_content += f'    {field_name} = IntField()\n'
            elif field_type in ["float", "decimal"]:
                model_content += f'    {field_name} = FloatField()\n'
            elif field_type in ["bool", "boolean"]:
                model_content += f'    {field_name} = BooleanField(default=False)\n'
            elif field_type == "text":
                model_content += f'    {field_name} = StringField()\n'
            else:
                model_content += f'    {field_name} = StringField(max_length=255)\n'
        
        # Add default fields if no custom fields
        if not fields:
            model_content += '''    name = StringField(max_length=255, required=True)
    description = StringField()
    is_active = BooleanField(default=True)
'''
        
        # Add timestamps if enabled
        if enable_timestamps:
            model_content += '''    created_at = DateTimeField(default=datetime.utcnow)
    updated_at = DateTimeField(default=datetime.utcnow)
'''
        
        model_content += f'''
    def __str__(self):
        return f"{model_name}({{getattr(self, 'name', 'N/A')}})"
    
    def to_dict(self):
        """Convert document to dictionary."""
        return self.to_mongo().to_dict()
    
    def save(self, *args, **kwargs):
        """Override save to update timestamp."""
        if hasattr(self, 'updated_at'):
            self.updated_at = datetime.utcnow()
        return super().save(*args, **kwargs)
'''
        
        model_file = output_path / f"{model_name.lower()}.py"
        model_file.write_text(model_content)
        
        return model_file
    
    def _generate_generic_model(self, variables: Dict[str, Any], output_path: Path) -> Path:
        """Generate generic Python model."""
        
        model_name = variables.get("model_name", "Item")
        fields = variables.get("fields", [])
        enable_timestamps = variables.get("enable_timestamps", True)
        
        model_content = f'''"""
Generic Python model for {model_name}.
Generated by FastAPI Microservices SDK.
"""

from dataclasses import dataclass, field
from typing import Optional
from datetime import datetime


@dataclass
class {model_name}:
    """Generic model for {model_name.lower()}."""
    
    id: Optional[int] = None
'''
        
        # Add custom fields
        for field_info in fields:
            field_name = field_info.get("name", "field")
            field_type = field_info.get("type", "str")
            
            if field_type in ["str", "string"]:
                model_content += f'    {field_name}: Optional[str] = None\n'
            elif field_type in ["int", "integer"]:
                model_content += f'    {field_name}: Optional[int] = None\n'
            elif field_type in ["float", "decimal"]:
                model_content += f'    {field_name}: Optional[float] = None\n'
            elif field_type in ["bool", "boolean"]:
                model_content += f'    {field_name}: bool = False\n'
            else:
                model_content += f'    {field_name}: Optional[str] = None\n'
        
        # Add default fields if no custom fields
        if not fields:
            model_content += '''    name: str = ""
    description: Optional[str] = None
    is_active: bool = True
'''
        
        # Add timestamps if enabled
        if enable_timestamps:
            model_content += '''    created_at: datetime = field(default_factory=datetime.utcnow)
    updated_at: datetime = field(default_factory=datetime.utcnow)
'''
        
        model_content += f'''
    def to_dict(self):
        """Convert model to dictionary."""
        return {{
            k: v.isoformat() if isinstance(v, datetime) else v
            for k, v in self.__dict__.items()
        }}
    
    @classmethod
    def from_dict(cls, data: dict):
        """Create model from dictionary."""
        return cls(**{{k: v for k, v in data.items() if k in cls.__annotations__}})
'''
        
        model_file = output_path / f"{model_name.lower()}.py"
        model_file.write_text(model_content)
        
        return model_file
    
    def _generate_pydantic_schemas(self, variables: Dict[str, Any], output_path: Path) -> Path:
        """Generate Pydantic schemas for validation."""
        
        model_name = variables.get("model_name", "Item")
        fields = variables.get("fields", [])
        enable_timestamps = variables.get("enable_timestamps", True)
        
        schema_content = f'''"""
Pydantic schemas for {model_name}.
Generated by FastAPI Microservices SDK.
"""

from pydantic import BaseModel, Field, ConfigDict
from typing import Optional
from datetime import datetime


class {model_name}Base(BaseModel):
    """Base schema for {model_name}."""
'''
        
        # Add custom fields
        for field_info in fields:
            field_name = field_info.get("name", "field")
            field_type = field_info.get("type", "str")
            
            if field_type in ["str", "string"]:
                schema_content += f'    {field_name}: str = Field(..., description="{field_name.title()}")\n'
            elif field_type in ["int", "integer"]:
                schema_content += f'    {field_name}: int = Field(..., description="{field_name.title()}")\n'
            elif field_type in ["float", "decimal"]:
                schema_content += f'    {field_name}: float = Field(..., description="{field_name.title()}")\n'
            elif field_type in ["bool", "boolean"]:
                schema_content += f'    {field_name}: bool = Field(False, description="{field_name.title()}")\n'
            else:
                schema_content += f'    {field_name}: str = Field(..., description="{field_name.title()}")\n'
        
        # Add default fields if no custom fields
        if not fields:
            schema_content += '''    name: str = Field(..., description="Name", min_length=1, max_length=255)
    description: Optional[str] = Field(None, description="Description", max_length=1000)
    is_active: bool = Field(True, description="Whether the item is active")
'''
        
        schema_content += f'''

class {model_name}Create({model_name}Base):
    """Schema for creating {model_name}."""
    pass


class {model_name}Update(BaseModel):
    """Schema for updating {model_name}."""
'''
        
        # Add optional fields for update
        for field_info in fields:
            field_name = field_info.get("name", "field")
            field_type = field_info.get("type", "str")
            
            if field_type in ["str", "string"]:
                schema_content += f'    {field_name}: Optional[str] = Field(None, description="{field_name.title()}")\n'
            elif field_type in ["int", "integer"]:
                schema_content += f'    {field_name}: Optional[int] = Field(None, description="{field_name.title()}")\n'
            elif field_type in ["float", "decimal"]:
                schema_content += f'    {field_name}: Optional[float] = Field(None, description="{field_name.title()}")\n'
            elif field_type in ["bool", "boolean"]:
                schema_content += f'    {field_name}: Optional[bool] = Field(None, description="{field_name.title()}")\n'
            else:
                schema_content += f'    {field_name}: Optional[str] = Field(None, description="{field_name.title()}")\n'
        
        # Add default fields if no custom fields
        if not fields:
            schema_content += '''    name: Optional[str] = Field(None, description="Name", min_length=1, max_length=255)
    description: Optional[str] = Field(None, description="Description", max_length=1000)
    is_active: Optional[bool] = Field(None, description="Whether the item is active")
'''
        
        schema_content += f'''

class {model_name}Response({model_name}Base):
    """Schema for {model_name} response."""
    model_config = ConfigDict(from_attributes=True)
    
    id: int = Field(..., description="Unique identifier")
'''
        
        # Add timestamps if enabled
        if enable_timestamps:
            schema_content += '''    created_at: datetime = Field(..., description="Creation timestamp")
    updated_at: datetime = Field(..., description="Last update timestamp")
'''
        
        schema_content += f'''

class {model_name}List(BaseModel):
    """Schema for paginated {model_name} list."""
    items: list[{model_name}Response] = Field(..., description="List of items")
    total: int = Field(..., description="Total number of items")
    page: int = Field(..., description="Current page number")
    size: int = Field(..., description="Page size")
    pages: int = Field(..., description="Total number of pages")
'''
        
        schema_file = output_path / f"{model_name.lower()}_schemas.py"
        schema_file.write_text(schema_content)
        
        return schema_file