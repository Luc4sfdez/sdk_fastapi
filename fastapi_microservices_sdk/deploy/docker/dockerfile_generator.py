"""
Dockerfile generator for FastAPI microservices.
"""

import os
from pathlib import Path
from typing import Dict, Any, Optional, List


class DockerfileGenerator:
    """Generate optimized Dockerfiles for FastAPI microservices."""
    
    def __init__(self):
        self.base_images = {
            "python3.8": "python:3.8-slim",
            "python3.9": "python:3.9-slim",
            "python3.10": "python:3.10-slim",
            "python3.11": "python:3.11-slim",
            "python3.12": "python:3.12-slim"
        }
    
    def generate(self, service_name: str, service_path: Path, config: Optional[Dict[str, Any]] = None) -> str:
        """Generate Dockerfile content for a service."""
        
        if config is None:
            config = self._detect_service_config(service_path)
        
        # Determine Python version
        python_version = config.get("python_version", "python3.11")
        base_image = self.base_images.get(python_version, "python:3.11-slim")
        
        # Build Dockerfile content
        dockerfile_content = self._generate_dockerfile_content(
            service_name=service_name,
            base_image=base_image,
            config=config,
            service_path=service_path
        )
        
        return dockerfile_content
    
    def _detect_service_config(self, service_path: Path) -> Dict[str, Any]:
        """Detect service configuration from files."""
        
        config = {
            "python_version": "python3.11",
            "port": 8000,
            "requirements_file": "requirements.txt",
            "main_file": "main.py",
            "enable_multi_stage": True,
            "enable_health_check": True,
            "enable_non_root_user": True,
            "dependencies": []
        }
        
        # Check for requirements.txt
        requirements_file = service_path / "requirements.txt"
        if requirements_file.exists():
            config["dependencies"] = self._parse_requirements(requirements_file)
        
        # Check for pyproject.toml
        pyproject_file = service_path / "pyproject.toml"
        if pyproject_file.exists():
            config["has_pyproject"] = True
        
        # Check for main.py or app.py
        if (service_path / "app.py").exists():
            config["main_file"] = "app.py"
        elif (service_path / "main.py").exists():
            config["main_file"] = "main.py"
        
        # Detect port from environment or config files
        env_file = service_path / ".env"
        if env_file.exists():
            port = self._extract_port_from_env(env_file)
            if port:
                config["port"] = port
        
        return config
    
    def _parse_requirements(self, requirements_file: Path) -> List[str]:
        """Parse requirements.txt file."""
        
        dependencies = []
        
        try:
            with open(requirements_file, 'r') as f:
                for line in f:
                    line = line.strip()
                    if line and not line.startswith('#'):
                        dependencies.append(line)
        except Exception:
            pass
        
        return dependencies
    
    def _extract_port_from_env(self, env_file: Path) -> Optional[int]:
        """Extract port from .env file."""
        
        try:
            with open(env_file, 'r') as f:
                for line in f:
                    line = line.strip()
                    if line.startswith('SERVICE_PORT=') or line.startswith('PORT='):
                        port_str = line.split('=', 1)[1].strip()
                        return int(port_str)
        except Exception:
            pass
        
        return None
    
    def _generate_dockerfile_content(
        self, 
        service_name: str, 
        base_image: str, 
        config: Dict[str, Any],
        service_path: Path
    ) -> str:
        """Generate the actual Dockerfile content."""
        
        if config.get("enable_multi_stage", True):
            return self._generate_multi_stage_dockerfile(service_name, base_image, config, service_path)
        else:
            return self._generate_simple_dockerfile(service_name, base_image, config, service_path)
    
    def _generate_multi_stage_dockerfile(
        self, 
        service_name: str, 
        base_image: str, 
        config: Dict[str, Any],
        service_path: Path
    ) -> str:
        """Generate multi-stage Dockerfile for optimized builds."""
        
        port = config.get("port", 8000)
        main_file = config.get("main_file", "main.py")
        requirements_file = config.get("requirements_file", "requirements.txt")
        
        dockerfile = f'''# Multi-stage Dockerfile for {service_name}
# Generated by FastAPI Microservices SDK

# Build stage
FROM {base_image} as builder

# Set environment variables
ENV PYTHONDONTWRITEBYTECODE=1 \\
    PYTHONUNBUFFERED=1 \\
    PIP_NO_CACHE_DIR=1 \\
    PIP_DISABLE_PIP_VERSION_CHECK=1

# Install system dependencies
RUN apt-get update \\
    && apt-get install -y --no-install-recommends \\
        build-essential \\
        curl \\
        git \\
    && rm -rf /var/lib/apt/lists/*

# Create virtual environment
RUN python -m venv /opt/venv
ENV PATH="/opt/venv/bin:$PATH"

# Copy requirements and install Python dependencies
COPY {requirements_file} .
RUN pip install --upgrade pip \\
    && pip install -r {requirements_file}

# Production stage
FROM {base_image} as production

# Set environment variables
ENV PYTHONDONTWRITEBYTECODE=1 \\
    PYTHONUNBUFFERED=1 \\
    PATH="/opt/venv/bin:$PATH"

# Install runtime dependencies only
RUN apt-get update \\
    && apt-get install -y --no-install-recommends \\
        curl \\
    && rm -rf /var/lib/apt/lists/*

# Copy virtual environment from builder stage
COPY --from=builder /opt/venv /opt/venv

# Create non-root user
RUN groupadd -r appuser && useradd -r -g appuser appuser

# Create app directory
WORKDIR /app

# Copy application code
COPY . .

# Change ownership to non-root user
RUN chown -R appuser:appuser /app

# Switch to non-root user
USER appuser

# Expose port
EXPOSE {port}

# Health check
HEALTHCHECK --interval=30s --timeout=30s --start-period=5s --retries=3 \\
    CMD curl -f http://localhost:{port}/health || exit 1

# Run the application
CMD ["python", "{main_file}"]
'''
        
        return dockerfile
    
    def _generate_simple_dockerfile(
        self, 
        service_name: str, 
        base_image: str, 
        config: Dict[str, Any],
        service_path: Path
    ) -> str:
        """Generate simple Dockerfile for development."""
        
        port = config.get("port", 8000)
        main_file = config.get("main_file", "main.py")
        requirements_file = config.get("requirements_file", "requirements.txt")
        
        dockerfile = f'''# Simple Dockerfile for {service_name}
# Generated by FastAPI Microservices SDK

FROM {base_image}

# Set environment variables
ENV PYTHONDONTWRITEBYTECODE=1 \\
    PYTHONUNBUFFERED=1

# Set work directory
WORKDIR /app

# Install system dependencies
RUN apt-get update \\
    && apt-get install -y --no-install-recommends \\
        curl \\
    && rm -rf /var/lib/apt/lists/*

# Copy requirements and install dependencies
COPY {requirements_file} .
RUN pip install --upgrade pip \\
    && pip install -r {requirements_file}

# Copy application code
COPY . .

# Expose port
EXPOSE {port}

# Health check
HEALTHCHECK --interval=30s --timeout=30s --start-period=5s --retries=3 \\
    CMD curl -f http://localhost:{port}/health || exit 1

# Run the application
CMD ["python", "{main_file}"]
'''
        
        return dockerfile
    
    def generate_dockerignore(self, service_path: Path) -> str:
        """Generate .dockerignore file content."""
        
        dockerignore_content = '''# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# Virtual environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db

# Logs
*.log
logs/

# Database
*.db
*.sqlite3

# Testing
.pytest_cache/
.coverage
htmlcov/
.tox/

# Documentation
docs/_build/

# Docker
Dockerfile
.dockerignore
docker-compose*.yml

# Git
.git/
.gitignore

# CI/CD
.github/
.gitlab-ci.yml
.travis.yml

# Temporary files
*.tmp
*.temp
.cache/

# Local development
.env.local
.env.development
.env.test
'''
        
        return dockerignore_content
    
    def generate_with_optimization(
        self, 
        service_name: str, 
        service_path: Path, 
        optimization_level: str = "production"
    ) -> str:
        """Generate Dockerfile with specific optimization level."""
        
        config = self._detect_service_config(service_path)
        
        if optimization_level == "development":
            config["enable_multi_stage"] = False
            config["enable_non_root_user"] = False
            config["enable_health_check"] = False
        elif optimization_level == "production":
            config["enable_multi_stage"] = True
            config["enable_non_root_user"] = True
            config["enable_health_check"] = True
        elif optimization_level == "minimal":
            config["enable_multi_stage"] = True
            config["enable_non_root_user"] = True
            config["enable_health_check"] = False
        
        return self.generate(service_name, service_path, config)
    
    def save_dockerfile(self, content: str, service_path: Path, filename: str = "Dockerfile") -> Path:
        """Save Dockerfile content to file."""
        
        dockerfile_path = service_path / filename
        dockerfile_path.write_text(content)
        
        return dockerfile_path
    
    def save_dockerignore(self, service_path: Path) -> Path:
        """Save .dockerignore file."""
        
        dockerignore_content = self.generate_dockerignore(service_path)
        dockerignore_path = service_path / ".dockerignore"
        dockerignore_path.write_text(dockerignore_content)
        
        return dockerignore_path